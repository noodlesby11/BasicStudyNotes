# 指令系统

---

## 概念与要求

### 指令系统的发展

**CISC**：复杂的指令系统计算机

**RISC**：精简的指令系统计算机

随着大规模集成电路技术的发展，计算机的硬件成本不断下降，软件成本不断提高，使得指令系统增加了更多更复杂的指令，以提高操作系统的效率。另外，同一系列的新型机对其指令系统只能扩充而不能减去旧型机的任意一条，以达到程序兼容。这样一来，指令系统越来越复杂，有的计算机指令甚至达到数百条。人们就称这种计算机为CISC（Complex Instruction Set Computer）。如IBM公司的大、中型计算机，Intel公司的8086、80286、80386微处理器等。

日益庞大的指令系统不仅使计算机研制周期变长，而且还有难以调试、难以维护等一些自身无法克服的缺点。

后来人们发现机器执行的指令中85％左右的都是简单指令，复杂指令甚少，因此开始研制精简指令系统计算机(RISC)。于是RISC技术在高端服务器和工作站上更是得到了广泛的应用。Intel的Pentium问世以来(92年末)，融合了RISC技术，也逐步渗透到了中小工作站和服务器市场。

这种种因素使计算机指令产生了“简单指令”和“复杂指令”之分。70年代以前的计算机均用传统的CISC指令结构，即完全采用复杂指令来支持高级语言、应用程序和操作系统。这种PC不但成本高且效率较低，速度受限。

目前，RISC和CISC各有优势，而且界限并不那么明显了。现代的CPU往往采用CISC的外围，内部加入了RISC的特性。就连 Intel最新的Pentium II等CISC芯片也具有了明显的RISC特征。另外，超长指令集CPU由于融合了RISC和CISC的优势，成为未来的CPU发展方向之一。

选自：<[RISC和CISC - faintbear - BlogJava](http://www.blogjava.net/faintbear/archive/2006/02/20/31698.html)>

### 性能要求

**完备性：**指令系统要指令丰富、功能齐全、使用方便。

**有效性：**要求指令编写的程序系统要能够高效的运行。

**规整性：**指令系统的对称性、允齐性，指令格式和数据格式的一致性。

**兼容性：**即“向上兼容”，低档机上能够运行的软件可以在高档机上运行。

----

## 指令格式

一般的指令格式为：<u>操作码字段OP+地址码字段A</u>

### 操作码

指令的操作码OP表示该指令的操作性质，如加减乘除、取数、存数等。每一种编码对应一种操作例如<u>001规定为加法。</u>

组成操作码字段的位数取决于计算机指令系统的规模，例如<u>8条指令就需要3位操作码、32条指令就需要5位操作码。</u>

### 地址码

根据一条指令中的有几个操作数地址，可将指令称为几操作数指令和几地址指令。一般操作数有被操作数、操作数、操作结果。

**零地址指令：**仅有OP码，无地址码。例如停机。

**一地址指令：**格式为：<u> OP码+A</u>只有一个地址码，另一个操作数的地址是隐含的。例如运算器中的累加寄存器AC中的数据为隐含的被操作数，在运算完后被重新覆盖掉。数学含义为 AC<——(AC)OP(A)。

**二地址指令：**格式为<u>OP码+A~1~+A~2~</u>  常称为双操作数指令,A~1~和A~2~分别注明两个数在内存中的通用寄存器的地址,A~1~兼做存放操作结果的地址。数学含义为：A~1~<——(A~1~)OP(A~2~)

按照操作数的物理位置可以分为三种类型：

*存储器存储器型指令（SS）*访问内存的指令格式。

*寄存器寄存器型指令（RR）*访问寄存器的指令格式。

*寄存器-存储器型指令（RS）*执行这种指令时既要访问内存单元又要访问寄存器。

**三地址指令：**格式为<u>OP码+A~1~+A~2~+A~3~</u>  A~1~为被操作数地址，A~2~为操作数地址，A~3~为存放操作结果的地址。为了加快指令的执行速度，三个操作数通常指定为运算器中通用寄存器的地址。数学含义为：A~3~<——(A~1~)OP(A~2~)

### 指令字的长度

**指令字长度：**一个指令字中包含二进制代码的位数。

**机器字长：**计算机能直接处理的二进制字长位数。

指令字长度=机器字长度，**单字长指令**

指令字长度=机器字长度的一半，**半字长指令**

指令字长=两个机器字长度，**双字长指令**

###操作码扩展技术

操作码扩展技术为了保持指令长度不变，扩展指令的数量。

>假设某机器字长为16位，包括4位操作码和三个4位的地址码。

4位操作码，==三地址指令==最多能有16条，若取其中1111作为地址扩展标识，条数变位==15条==。

取A~1~域为4位，连同4位操作码共8位作为操作码，其中前4位为1111操作码，所以==二地址指令==最多也为16条，分别为11110000~11111111，若取其中11111110和11111111作地址扩展标识，条数变为==14条==。

取A~1~、A~2~域和4位操作码共12位作为一地址指令操作码，前8位分别位11110000和11111111，所以==一地址指令==最多有32条，若取其中111111111111位地址扩展标识，条数变为==31条==。

==零地址指令==长度为16位，前12位为111111111111的地址扩展标识，所以共有==16条==指令

<u>对于不同位数的机器字长和不同长度的操作码地址码，都可以用此方法进行操作码的扩展。</u>

----

## 指令和数据的寻址方式

### 指令的寻址方式

#### 顺序寻址

从存储器中取出第一条指令，执行，然后取出第二条指令，执行………顺序执行。所以要用**程序计数器PC**计算指令的顺序号，根据顺序号取指。每次取指PC+1（存储一条指令占用的字节单元数）。

#### 跳跃寻址

下条指令的地址码不是程序计数器给出，而是由指令给出下条指令的地址。采用跳跃寻址的方式，可以实现程序转移或者构成循环程序。

### 操作数的基本寻址方式

操作数的来源：

1. 地址码直接给出操作数，地址码就是操作数。
2. 操作数在CPU的通用数据寄存器中。
3. 内存的数据区中。

操作数的的实际访存地址称为**有效地址EA**，指令地址地段给出的地址根据转换才能变换为有效地址的称为**形式地址A**。

**隐含寻址：**不明显给出操作数地址，指令中隐含操作数地址。例如累加寄存器AE。

**立即寻址：**地址字段就是操作数，称为立即数。特点为执行速度快。==操作数=A==。

**直接寻址：**指令的地址字段直接给出操作数的<u>内存地址</u>，访问主存，速度比较慢。==EA＝A==。

**间接寻址：**相对于直接寻址，指令字段中的形式地址A是有效地址的地址，A给出的地址是操作数地址的指示器。由于需要访问两次主存所以速度很慢，但是解决了直接寻址地址字段的位数限制访存大小的问题。==EA=（A）==，括号代表访问。

**寄存器寻址：**操作数不在内存中，而在CPU的通用寄存器中。指令中给出的操作数地址是通用寄存器的编号，寄存器中有操作数。执行速度快，==EA=R==

**寄存器间接寻址：**与寄存器寻址的区别为，寄存器中的内容不是操作数，而是操作数在内存中的地址。解决了间接寻址访问速度慢的问题。==EA=（R）==

**偏移寻址**是直接寻址和寄存器寻址结合，将形式地址A与专用寄存器R中的地址想加，得到真正的有效地址。根据寄存器的不同分为**相对寻址**、**基址寻址**、**变址寻址**，==EA=A+（R）==

**相对寻址：**专用寄存器位程序计数器PC，将PC的值加上形式地址A的值，再加上补码数2（16位）得到EA。==EA＝A＋（PC）==

**基址寻址：**专用寄存器为基址寄存器，提供了范围很大的存储空间。==EA=（R）+A==（R代表基址寄存器）

**变址寻址：**专用寄存器为变址寄存器，变址寄存器的值可变，所以补改变指令就可以改变数据的有效地址，可以在循环结构中使用。==EA=（R）+A==（R代表变址寄存器）

**堆栈寻址：**需要一个隐式或显示的堆栈指示器（寄存器），PUSH时加1，POP时减一，数据始终位于栈顶。

| 寻址方式       | 算法                   | 特点                                         |
| -------------- | ---------------------- | -------------------------------------------- |
| 隐含寻址       | 操作数在隐含的寄存器中 | 数据范围有限                                 |
| 立即寻址       | 操作数=A               | 快，便于程序设计，赋初值，值的大小受限       |
| 直接寻址       | EA=A                   | 慢，便于程序设计，访问范围受限               |
| 间接寻址       | EA＝（A）              | 很慢，解决了访问范围受限的问题               |
| 寄存器寻址     | EA=R                   | 快，便于程序设计，不能访问主存               |
| 寄存器间接寻址 | EA＝（R）              | 慢，便于程序设计，提供访存，范围大           |
| 相对寻址       | EA=A+（PC）            | 慢，提供访存，不能在循环中使用               |
| 变址寻址       | EA＝A+（R1）           | 慢，便于程序设计，提供访存，可在循环中使用   |
| 基址寻址       | EA=A+（R2）            | 慢，提供更大的范围访存能力，不能在循环中使用 |
| 堆栈寻址       | EA=栈顶                | 需要堆栈指示器                               |











