# 数据的表示

---

## 数据格式

### 定点数

定点数就是机器中小数点位置是固定不变的。按照小数点在哪里可以分为**纯小数**和**纯整数**

> 设任意定点数为x=x~n~x~n-1~…x~1~x~0~

最高位x~n~用0和1表示符号，其余位数表示量值表示尾数。

若==小数点在尾数后面==称为==纯整数==；X的取值范围为0<=|X|<=2^n-1^

若==小数点在符号后面==称为==纯小数==。X的取值范围为0<=|X|<=1-2^-n^

### 浮点数

用科学计数法的数（9X10^10^）无法用定点数表示，就要用浮点数表示。

把数据的精度分别表示，相当于数的小数点位置随比例因子的不同而在一定范围内浮动。

十进制表示：N=10^e^.M

二进制表示：N=2^e^.M	(M称为尾数，e称为指数通常为整数也叫**阶码**，2为基数)

一个机器浮点数的由阶码和尾数及其符号组成。

> 浮点数N=E~s~E~m-1~…E~1~E~0~M~s~M~n-1~…M~1~M~0~

| E~s~ | E~m-1~…E~1~E~0~ | M~s~ | ~s~M~n-1~…M~1~M~0~ |
| ---- | --------------- | ---- | ------------------ |
| 阶符 | 阶码            | 数符 | 尾数               |

### 十进制数串

**字符串形式：**1个字节存放一个十进制的数位或符号位。

**压缩的十进制数串形式：**1个字节存放两个十进制的数位或符号位。每个数位占半个字节，可用BCD码或数字符的ASCII码的低4位表示。

---

## 数的机器码表示

### 原码

定点整数原码就是符号位加上二进制数的绝对值。

> x=+10011,[x]~原~=010011
>
> x=-10011,[x]~原~=110011
>
> 0有+0和-0之分

优点是表示简单，缺点位加法运算复杂。

### 补码

**模（mod）的定义：**模表示被丢掉的数值，例如：7+9=4（mod12）超过12的数舍弃12。

当以12为模时，-4=+8，此时-4和+8互为补码。

定点整数的补码定义式：

> [x]~补~=x,  2^n^>x>0
>
> [x]~补~=2^n+1^+x,  0>=x>=-2^n^

由原码直接转变为补码：

* 正整数：符号位为0，原码=反码=补码

* 负整数：符号位为1，其余数位取反，再+1，得到补码。

### 移码

移码通常用于表示浮点数的阶码，阶码位k位整数。

>[e]~移~=2^k^+e,  2^k^>e>=-2^k^ (e为真值，2^k^为一个固定偏移量常数)

定点数的移码可以简单计算为补码的符号位取反，即为移码。

### 浮点数的机器表示

IEEE754标准中浮点数的标准格式为：

| S（符号位）  | E（阶码） | M（尾数） |
| ------------ | --------- | --------- |
| 32位短浮点数 |           |           |
| 占1位        | 占8位     | 占23位    |
| 64位长浮点数 |           |           |
| 占1位        | 占11位    | 占52位    |

**在32位短浮点数中：**

S=0位正数，S=1为负数；尾数M的小数点在尾域的最左；阶码E用移码表示正负，所以E对于正值e会有一个偏移量，即E=e+127.

**一个规格化的32位浮点数x的真值表示为：**x=(-1)^s^X(1.M)X2^E-127^

>Q：将浮点数（41360000）~16~，求十进制数值。
>
>A：展开为0 10000010 01101100000000000000000
>
>e=阶码-127=10000010-01111111=00000011=(3)~10~
>
>1.M=1.011011
>
>x=(-1)^s^X(1.M)X2^E-127^=+(1.011011)X2^2^=+1=11.011=(11.375)~10~



>Q:将（20.59375）~10~转换成32位浮点数的二进制格式。
>
>A：先转换位二进制，20.59375=(10100.10011)~2~
>
>移动小数点，10100.10011=1.010010011X2^4^即e=4
>
>所以S=0，E=4+127=131，M=010010011
>
>二进制存储格式为0100 0001 1010 0100 1100 0000 0000 0000=（41A4C000）~16~

---

## 字符（串）的表示方法

采用ASCII码，包含128个元素，因此需要二进制编码需要7位，加上偶校验位，共8位，一字节。

ASCII码规定8个二进制码位的最高一位为0，余下7位可以给出128个编码。

字符串是指连续的一串字符，它们占用主存中连续的多字节，每个字节放一个字符。当主存字由2或4进制字节组成时，在一个主存字中可以按照高位向地位放字符串，也可以按照低位向高位放字符串。

---

## 校验码

二进制数在传输过程中会由于各种原因会出错，使数据接受错误。为了检测这种错误，在每个字上添加一些校验位，用来确定字中出现错误的位置。

> 设X=（x~0~x~1~…x~n-1~）是一个n位字。

**奇校验位$\overline{\text{C}}$：**$\overline{\text{C}}$=x~0~$\bigoplus$x~1~$\bigoplus$…$\bigoplus$x~n-1~（$\bigoplus$表示按位加）

表示只有X中包含奇数个1时，才能使$\overline{\text{C}}$=1，即C=0。

**偶校验位C：**C=x~0~$\bigoplus$x~1~$\bigoplus$…$\bigoplus$x~n-1~

表示只有X中包含偶数个1时，C=0。

> 假设X从A传送到B，在源点A可以算出C，然后将C加到X后面传输到B，B接收到X然后计算，将X和校验码C都进行按位加法计算，若结果F=1，表示有错，若F=0，表示正确。

奇校验提供奇数个错误检验，偶校验提供偶数个错误检验，无法识别错误位置。

# 运算方法

---

## 补码加法

**补码的加法公式：**[x]~补~+[y]~补~=[x+y]~补~

>Q：已知X=+10010 Y=-10101 求X+Y
>
>A：[x]~补~=010010，[y]~补~=101011
>
>[x+y]~补~=[x]~补~+[y]~补~=111101
>
>所以：X+Y=-00011

---

## 补码减法

**补码的减法公式：**[X-Y]~补~=[x]~补~-[y]~补~=[x]~补~+[-y]~补~

从[y]~补~求[-y]~补~：对[y]~补~包括符号位==求反且末位加1==得到[-y]~补~。

>Q：x=+1101,y=+01110,求x-y。
>
>A：[x]~补~=01101，[y]~补~=00110，[-y]~补~=11010
>
>[X-Y]~补~=01101+11010=00111
>
>x-y=+0111

---

## 溢出概念与检测方法

### 溢出概念

在定点整数的机器中数的范围为|x|<(2^n^-1)。若在运算过程中出现大于字长的绝对值的现象，称为**溢出**。

**正溢：**两个正数相加，结果大于机器字长所能表示的最大正整数。

**负溢：**两个负数相加，结果小于机器字长所能表示的最小负数。

### 检测方法

**方法一：**对运算数和运算结果的符号进行检测，若符号不一样则出现了溢出。

**方法二：**对最高数据位进位和符号进位进行检测。

当最高有效位产生进位而符号位无进位时，产生正溢：当最高有效位无进位而符号位有进位，产生负溢。

**方法三：**采用变形补码（双符号位法）。

采用变形补码后：任何正数，符号位为00；任何负数，符号位为11。

若结果的符号==为01表示正溢==，==10为负溢==。
